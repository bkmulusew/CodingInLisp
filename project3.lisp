#||

Name: Beakal Lemeneh
Net ID: 31390484
Project: 03

||#

(defun append (list1 list2)
	(if (null list1)
		list2
		(cons (car list1)(append (cdr list1) list2))))

(defun reverseRec (list1 list2)
	(if (null list1)
		list2
		(reverseRec (cdr list1) (cons (car list1) list2))))

(defun reverse (list1)
	(reverseRec list1 '()))

(defun add3 (x) 
	(+ 3 x))

(defun map (func list1)
	(if (null list1)
		nil
		(cons (funcall func (car list1)) (map func (cdr list1)))))

(defun nubRec (list1 list2)
	(if (null list1)
		list2
		(nubRec (cdr list1) (insert (car list1) list2))))

(defun nub (list1)
	(reverse (nubRec list1 '())))

(defun fold (num func list1)
	(if (null list1)
		num
		(fold (funcall func num (car list1)) func (cdr list1))))

(defun lessthan3 (x) 
	(< x 3))

(defun filter (func list1)
	(cond 
  		((null list1) 
  			nil)
  		((funcall func (car list1))
			(cons (car list1) (filter func (cdr list1))))
  		(t (filter func (cdr list1)))))

(defun merge (list1 list2)
	(cond 
		((and (null list1) (null list2)) 
			nil)
		((null list1) 
			list2)
		((null list2) 
			list1)
		((<= (car list1) (car list2))
			(cons (car list1) (merge (cdr list1) list2)))
		((> (car list1) (car list2))
			(cons (car list2) (merge list1 (cdr list2))))))

(defun addtoend (ch list1)
	(reverse (cons ch (reverse list1))))

(defun indexRec (ch list1 cnt)
	(cond 
  		((null list1) 
  			(- 1))
  		((eq ch (car list1))
			cnt)
  		(t (indexRec ch (cdr list1) (+ cnt 1)))))

(defun indexof(ch list1)
	(indexRec ch list1 0))

(defun removeRec(ch list1 list2)
	(cond 
  		((null list1) 
  			list2)
  		((eq ch (car list1))
			(removeRec ch (cdr list1) list2))
  		(t (removeRec ch (cdr list1) (cons (car list1) list2)))))

(defun removeall(ch list1)
	(reverse (removeRec ch list1 '())))

(defun member (ch list1)
	(cond 
  		((null list1) 
  			nil)
  		((equal ch (car list1))
			t)
  		(t (member ch (cdr list1)))))

(defun insert (ch set1)
	(if (not (member ch set1))
		(cons ch set1)
		set1))

(defun intersection (set1 set2)
	(cond 
  		((null set1)
  			nil)
  		((member (car set1) set2)
			(cons (car set1) (intersection (cdr set1) set2)))
  		(t (intersection (cdr set1) set2))))

(defun unionRec (set1 set2 set3)
	(nub(append set1 (append set2 set3))))

(defun union (set1 set2)
	(unionRec set1 set2 '()))

(defun difference (set1 set2)
	(cond 
  		((null set1)
  			nil)
  		((member (car set1) set2)
  			(difference (cdr set1) set2))
  		(t (cons (car set1) (difference (cdr set1) set2)))))

(defun symdiff (set1 set2)
	(difference (union set1 set2) (intersection set1 set2)))

(defun subsetp (set1 set2)
	(cond 
  		((null set1) 
  			t)
  		((null set2)
			nil)
  		((equal (car set1) (car set2))
			(subsetp (cdr set1) (cdr set2)))
  		(t (subsetp set1 (cdr set2)))))

(defun supersetp (set1 set2)
	(subsetp set2 set1))

(defun cardinalityRec (set1 cnt)
	(if (null set1)
		cnt
		(cardinalityRec (cdr set1) (+ cnt 1))))

(defun cardinality (set1)
	(cardinalityRec set1 0))

(defun powerset (set1)
	(cond
		((null set1)
			(list nil))
		((equal 1 (cardinality set1))
			(list set1 (list nil)))
		(T
			(nub (append (append (append (append (append (list set1) (list (list (car set1)))) (list (cdr set1))) (list (cons (car set1)(list (car (cdr set1)))))) (list (cons (car set1)(list (car (reverse set1)))))) (powerset(cdr set1)))))))

(defun abs (num)
	(if (> num 0)
		num
		(- num)))

(defun factorial (n)
	(if (<= n 1)
		1
		(* n (factorial (- n 1)))))

(defun righttri (num1 num2 num3)
	(if (equal (* num3 num3) (+ (* num2 num2) (* num1 num1)))
		t
		nil))

(defun gcd (num1 num2)
	(if (equal num2 0)
		num1
		(gcd num2 (mod num1 num2))))

(defun lcm (num1 num2)
	(/ (* num1 num2) (gcd num1 num2)))

(defun nthfibo(n)
  (cond
    ((eq n 0) 
    	0)
    ((eq n 1) 
    	1)
    (t (+ (nthfibo (- n 1)) (nthfibo (- n 2))))))

(defun isPrime (num1 i)
	(if (eq 0 num1) 
		nil
		(if (eq 1 num1) 
			nil
			(if (>= i num1) 
				t
				(if (not (= (mod num1 i) 0))
					(isPrime num1 (+ i 1))
					nil)))))

(defun primep (num)
	(isPrime num 2))

(defun nthprimeRec (index i prime)
	(cond
		((eq index i)
			(- prime 1))
		((not(primep prime)) 
			(nthprimeRec index i (+ 1 prime)))
		((primep prime)
			(nthprimeRec index (+ 1 i) (+ 1 prime)))))

(defun nthprime (index)
	(nthprimeRec index 0 1))

(defun perfectpRec (num1 factorSum i)
	(cond
		((equal num1 factorSum)
			t)
		((> i num1)
			nil)
		((equal (mod num1 i) 0)
			(perfectpRec num1 (+ factorSum i) (+ i 1)))
		(t (perfectpRec num1 factorSum (+ i 1)))))

(defun perfectp (num1) 
	(perfectpRec num1 0 1))

(defun abundantRec (num1 factorSum i)
	(cond
		((>= i num1)
			(if (> factorSum num1)
				t
				nil))
		((> i num1)
			nil)
		((equal (mod num1 i) 0)
			(abundantRec num1 (+ factorSum i) (+ i 1)))
		(t (abundantRec num1 factorSum (+ i 1)))))

(defun abundantp (num1) 
	(abundantRec num1 0 1) )

(defun deficientp (num1)
	(cond
		((abundantp num1)
			nil)
		((perfectp num1)
			nil)
		(t)))

(defun main()
	(format t "***~%")
	(format t "*** CSC173 Computation and Formal Systems~%")
	(format t "*** Project 3: Functional Programming in Lisp~%")
	(format t "*** Beakal Lemeneh~%")
	(format t "***~%")

	(format t "~%List functions~%")
	(format t "1 == APPEND~%")
	(format t "2 == REVERSE~%")
	(format t "3 == MAP~%")
	(format t "4 == NUB~%")
	(format t "5 == FOLD~%")
	(format t "6 == FILTER~%")
	(format t "7 == MERGE~%")
	(format t "8 == ADDTOEND~%")
	(format t "9 == INDEXOF~%")
	(format t "10 == REMOVE-ALL~%")

	(format t "~%Set functions~%")
	(format t "11 == MEMBER~%")
	(format t "12 == INSERT~%")
	(format t "13 == INTERSECTION~%")
	(format t "14 == UNION~%")
	(format t "15 == DIFFERENCE~%")
	(format t "16 == SYMDIFF~%")
	(format t "17 == SUBSETP~%")
	(format t "18 == SUPERSETP~%")
	(format t "19 == CARDINALITY~%")
	(format t "20 == POWERSET~%")

	(format t "~%Math functions~%")
	(format t "21 == ABS~%")
	(format t "22 == FACTORIAL~%")
	(format t "23 == RIGHT-TRI~%")
	(format t "24 == GCD~%")
	(format t "25 == LCM~%")
	(format t "26 == NTH-FIBO~%")
	(format t "27 == PRIMEP~%")
	(format t "28 == NTH-PRIME~%")

	(format t "~%Required functions~%")
	(format t "29 == PERFECTP~%")
	(format t "30 == ABUNDANTP~%")
	(format t "31 == DEFICIENTP~%")

	(format t "~%Enter a number corresponding to the function you want to execute:~%")
	(setq input (read))
	(execute input))

(defun execute (input)
	(cond
		((eq input 1)
			(format T "~%APPEND:~%")
			(format T "Enter list 1:~%")
			(setq list1 (read))
			(format T "Enter list 2:~%")
			(setq list2 (read))
			(setq result (append list1 list2))
			(format T "APPEND returns --> ")
			(write result))
		((eq input 2)
			(format T "~%REVERSE:~%")
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (reverse list1))
			(format T "REVERSE returns --> ")
			(write result))
		((eq input 3)
			(format T "~%MAP:~%")
			(format T "Enter a function:~%")
			(setq func (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (map func list1))
			(format T "MAP returns --> ")
			(write result))
		((eq input 4)
			(format T "~%NUB:~%")
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (nub list1))
			(format T "NUB returns --> ")
			(write result))
		((eq input 5)
			(format T "~%FOLD:~%")
			(format T "Enter an initial value:~%")
			(setq num (read))
			(format T "Enter a function:~%")
			(setq func (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (fold num func list1))
			(format T "FOLD returns --> ")
			(write result))
		((eq input 6)
			(format T "~%FILTER:~%")
			(format T "Enter a function:~%")
			(setq func (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (filter func list1))
			(format T "FILTER returns --> ")
			(write result))
		((eq input 7)
			(format T "~%MERGE:~%")
			(format T "Enter list 1:~%")
			(setq list1 (read))
			(format T "Enter list 2:~%")
			(setq list2 (read))
			(setq result (merge list1 list2))
			(format T "MERGE returns --> ")
			(write result))
		((eq input 8)
			(format T "~%ADDTOEND:~%")
			(format T "Enter an element to be added to the end of the list:~%")
			(setq element (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (addtoend element list1))
			(format T "ADDTOEND returns --> ")
			(write result))
		((eq input 9)
			(format T "~%INDEXOF:~%")
			(format T "Enter an element to find its index:~%")
			(setq element (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (indexof element list1))
			(format T "INDEXOF returns --> ")
			(write result))
		((eq input 10)
			(format T "~%REMOVE-ALL:~%")
			(format T "Enter an element to be removed from a list:~%")
			(setq element (read))
			(format T "Enter a list:~%")
			(setq list1 (read))
			(setq result (removeall element list1))
			(format T "REMOVE-ALL returns --> ")
			(write result))
		((eq input 11)
			(format T "~%MEMBER:~%")
			(format T "Enter an element to check its membership in a set:~%")
			(setq element (read))
			(format T "Enter a set:~%")
			(setq list1 (read))
			(setq result (member element list1))
			(format T "MEMBER returns --> ")
			(write result))
		((eq input 12)
			(format T "~%INSERT:~%")
			(format T "Enter an element to insert to a set:~%")
			(setq element (read))
			(format T "Enter a set:~%")
			(setq set1 (read))
			(setq result (insert element set1))
			(format T "INSERT returns --> ")
			(write result))
		((eq input 13)
			(format T "~%INTERSECTION:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (intersection set1 set2))
			(format T "INTERSECTION returns --> ")
			(write result))
		((eq input 14)
			(format T "~%UNION:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (union set1 set2))
			(format T "UNION returns --> ")
			(write result))
		((eq input 15)
			(format T "~%DIFFERENCE:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (difference set1 set2))
			(format T "DIFFERENCE returns --> ")
			(write result))
		((eq input 16)
			(format T "~%SYMDIFF:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (symdiff set1 set2))
			(format T "SYMDIFF returns --> ")
			(write result))
		((eq input 17)
			(format T "~%SUBSETP:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (subsetp set1 set2))
			(format T "SUBSETP returns --> ")
			(write result))
		((eq input 18)
			(format T "~%SUPERSETP:~%")
			(format T "Enter set 1:~%")
			(setq set1 (read))
			(format T "Enter set 2:~%")
			(setq set2 (read))
			(setq result (supersetp set1 set2))
			(format T "SUPERSETP returns --> ")
			(write result))
		((eq input 19)
			(format T "~%CARDINALITY:~%")
			(format T "Enter a set:~%")
			(setq set1 (read))
			(setq result (cardinality set1))
			(format T "CARDINALITY returns --> ")
			(write result))
		((eq input 20)
			(format T "~%POWERSET:~%")
			(format T "Enter a set:~%")
			(setq set1 (read))
			(setq result (powerset set1))
			(format T "POWERSET returns --> ")
			(write result))
		((eq input 21)
			(format T "~%ABS:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (abs num1))
			(format T "ABS returns --> ")
			(write result))
		((eq input 22)
			(format T "~%FACTORIAL:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (factorial num1))
			(format T "FACTORIAL returns --> ")
			(write result))
		((eq input 23)
			(format T "~%RIGHT-TRI:~%")
			(format T "Enter the length of side 1:~%")
			(setq num1 (read))
			(format T "Enter the length of side 2:~%")
			(setq num2 (read))
			(format T "Enter the length of the hypotenuse:~%")
			(setq num3 (read))
			(setq result (righttri num1 num2 num3))
			(format T "RIGHT-TRI returns --> ")
			(write result))
		((eq input 24)
			(format T "~%GCD:~%")
			(format T "Enter your 1st number:~%")
			(setq num1 (read))
			(format T "Enter your 2nd number:~%")
			(setq num2 (read))
			(setq result (gcd num1 num2))
			(format T "GCD returns --> ")
			(write result))
		((eq input 25)
			(format T "~%LCM:~%")
			(format T "Enter your 1st number:~%")
			(setq num1 (read))
			(format T "Enter your 2nd number:~%")
			(setq num2 (read))
			(setq result (lcm num1 num2))
			(format T "LCM returns --> ")
			(write result))
		((eq input 26)
			(format T "~%NTH-FIBO:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (nthfibo num1))
			(format T "NTH-FIBO returns --> ")
			(write result))
		((eq input 27)
			(format T "~%PRIMEP:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (primep num1))
			(format T "PRIMEP returns --> ")
			(write result))
		((eq input 28)
			(format T "~%NTH-PRIME:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (nthprime num1))
			(format T "NTH-PRIME returns --> ")
			(write result))
		((eq input 29)
			(format T "~%PERFECTP:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (perfectp num1))
			(format T "PERFECTP returns --> ")
			(write result))
		((eq input 30)
			(format T "~%ABUNDANTP:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (abundantp num1))
			(format T "ABUNDANTP returns --> ")
			(write result))
		((eq input 31)
			(format T "~%DEFICIENTP:~%")
			(format T "Enter a number:~%")
			(setq num1 (read))
			(setq result (deficientp num1))
			(format T "DEFICIENTP returns --> ")
			(write result))
		(t
			(format T "~%WRONG INPUT~%")
			(format T "Enter a valid number next time!!~%")))

(format t "~%")
(format t "~%Enter a number corresponding to the function you want to execute. Enter 0 to exit:~%")

(setq input2 (read))
(if (eq input2 0)
	(format t "~%END OF PROGRAM")
	(execute input2)))

(main)



